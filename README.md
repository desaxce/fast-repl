# Fast REPL

Server to check Lean proofs, via API.
Resource limits only work on Linux.

## Usage

```python
uv run uvicorn src.fast_repl.main:app
```

```
export API_KEY="secret123"
docker-compose up -d
curl -H "Authorization: Bearer secret123" \
     -X POST http://localhost:8000/api/check \
     -d '{"snippets":[{"id":"1","code":"..." }],"timeout":5}' \
     -H "Content-Type: application/json"
```

Check docs at http://localhost:8000/docs or http://localhost:8000/redoc.

And test with:
```
curl -X POST http://localhost:8000/api/check/ \
  -H "Content-Type: application/json" \
  -d '{"cmd":"#check 1 + 1"}'
```

Environment variables to configure the REPL pool:

```
MAX_REPLS   # Maximum number of concurrently running REPLs
_MAX_REUSE   # Maximum number of times to reuse a REPL
MEMORY_GB   # Memory limit for each REPL
INIT_REPLS  # Number of REPLs created at startup
```

## Contribute

Run `uv run pre-commit install` so that typing/linting run on commit.
Run `uv run pre-commit install --install-hooks`
And `uv run pre-commit install --hook-type pre-push` for tests to run on git push.

To run performance tests: `uv run pytest -m "performance"`. Use -s to view logs.

## Dependencies

- [REPL](https://github.com/leanprover-community/repl)
- [Mathlib](https://github.com/leanprover-community/mathlib4) library

## Notes on REPL

When running a [REPL](https://github.com/leanprover-community/repl) using `lake env repl`,
two processes appear on the host machine (or container):
- one for lake corresponding to the command you run: `lake env repl` which itself forked...
- ...a second process corresponding to the `.lake/build/bin/repl` executable.

The first one has a negligible memory/CPU footprint, only the second can use monitoring. 

### Windows vs. Mac vs. Linux

On Windows and Mac, there are no limits on the resources (memory or CPU) a spawned REPL
process can access. Should the Lean 4 code to evaluate contain options such as 
`set_option maxHeartbeats 0` and compute/memory heavy tactics, the REPL will greedily
consume what is available until it reaches an OOM or slows down your whole machine for CPU. 
The CPU appears to be less of a concern because most REPL processes consume a maximum of
one core at a time: this is due to Lean 4 tactics usually being non-threaded. 
See CPU consumption per proof on Goedel. // TODO: run goedel experiments

On Linux, we can limit the memory resource with the variable REPL_MEMORY_GB.

Regarding CPU, whether on Linux, Windows or Mac, we recommend understanding the types of proofs
to be evaluated on your REPL and having an average idea of the CPU required per proof. 
If you don't have a clear idea of the proof (generated by AI for instance) you can
use the Goedel CPU consumption (1 vCPU per proof) to limit the number of concurrent REPLs
running on the machine and set an appropriate timeout for proofs to avoid clogs (when the server
has reached the maximum number of REPLs to spawn, the API returns a 429). 
